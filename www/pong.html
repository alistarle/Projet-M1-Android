<html>

<head>
    <!--
        Customize this policy to fit your own app's needs. For more guidance, see:
            https://github.com/apache/cordova-plugin-whitelist/blob/master/README.md#content-security-policy
        Some notes:
            * gap: is required only on iOS (when using UIWebView) and is needed for JS->native communication
            * https://ssl.gstatic.com is required only on Android and is needed for TalkBack to function properly
            * Disables use of inline scripts in order to mitigate risk of XSS vulnerabilities. To change this:
                * Enable inline JS: add 'unsafe-inline' to default-src
            -->
            <meta http-equiv="Content-Security-Policy" content="default-src *; style-src 'self' 'unsafe-inline'; script-src 'self' 'unsafe-inline' 'unsafe-eval'">
            <meta name="format-detection" content="telephone=no">
            <meta name="msapplication-tap-highlight" content="no">
            <meta name="viewport" content="user-scalable=no, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width">
            <link rel="stylesheet" type="text/css" href="css/styleGame.css">
            <script src="js/phaser.min.js"></script>
            <script src="js/gyro.js"></script>

            <title>Hello World</title>
        </head>

        <body>
            <script type="text/javascript">
                window.onload = function() {

        //variable game avec resolution
        var game = new Phaser.Game(1080 , 1920, Phaser.AUTO, '', {
            preload: preload,
            create: create,
            update: update
        });

        //variable de coordonees 
        var Y = 1000;
        //scores
        var scorePlayer;
        var scoreCompute0;

        //gameObjects
        var playerBet;
        var computerBet;
        var ball;

        var scoreText;

        //valeurs pouvant Ãªtre modifiees
        var computerBetSpeed = 400;
        var ballSpeed = 500;
        var ballReleased = false;

        function preload() {
            //chargement des assets
            game.load.image('bet', 'assets/bet.png');
            game.load.image('ball', 'assets/ball.png');
            game.load.bitmapFont('font', 'assets/flappyfont.png', 'assets/flappyfont.fnt');
            game.load.bitmapFont('flappyfont', 'assets/flappyfont.png', 'assets/flappyfont.fnt');
        }


        function create() {
            //OnCreate initialisation des objets avec sprites et physique

            game.scorePlayer = 0;
            game.scoreComputer = 0;

            game.physics.startSystem(Phaser.Physics.ARCADE);
            game.stage.backgroundColor = '#DDDDDD';
            playerBet = createBet(game.world.centerX, game.height-80);
            computerBet = createBet(game.world.centerX, 80);
            ball = game.add.sprite(game.world.centerX, game.world.centerY, 'ball');
            game.physics.arcade.enable(ball);

            ball.anchor.setTo(0.5, 0.5);
            ball.body.collideWorldBounds = true;
            ball.body.bounce.setTo(1, 1);
            game.input.onDown.add(releaseBall, this);

            game.scoreText = game.add.bitmapText(game.width / 2 - 230, 0, 'flappyfont', game.scorePlayer.toString() + ":" + game.scoreComputer.toString(), 50);
            game.scoreText.visible = true;

            this.scale.scaleMode = Phaser.ScaleManager.EXACT_FIT;

            gyro.frequency = 2;
            gyro.startTracking(function(o) {
                var gyroX = o.gamma*15+ game.width / 2;
                if(gyroX>0 && gyroX<game.width){
                    playerBet.x = gyroX;
                }

           });


        }

        function createBet(x, y) {
            //creer une raquette
            var bet = game.add.sprite(x, y, 'bet');
            game.physics.arcade.enable(bet);
            bet.anchor.setTo(0.5, 0.5);
            bet.body.collideWorldBounds = true;
            bet.body.bounce.setTo(1, 1);
            bet.body.immovable = true;

            return bet;
        }

        function releaseBall() {
            if (!ballReleased) {
                ball.body.velocity.x = ballSpeed;
                ball.body.velocity.y = -ballSpeed;
                ballReleased = true;
            }
        }

        function checkGoal() {
            //si but alors score++
            if (ball.y < 80) {
                setBall();
                game.scorePlayer++;
            } else if (ball.y > game.height-80) {
                setBall();
                game.scoreComputer++;
            }
            updateScore();
        }

        function updateScore() {
            //refresh affichage du score
            game.scoreText.setText("player " + game.scorePlayer.toString() + " : " + game.scoreComputer.toString() + " computer");
        }

        function setBall() {
            //balle au centre
            if (ballReleased) {
                ball.x = game.world.centerX;
                ball.y = game.world.centerY;
                ball.body.velocity.x = 0;
                ball.body.velocity.y = 0;
                ballReleased = false;
            }
        }

        function ballHitsBet(_ball, _bet) {
            //physique balle+raquette
            var diff = 0;

            //gauche
            if (_ball.x < _bet.x) {
                diff = _bet.x - _ball.x;
                _ball.body.velocity.x = (-10 * diff);
                //droite
            } else if (_ball.x > _bet.x) {
                diff = _ball.x - _bet.x;
                _ball.body.velocity.x = (10 * diff);
            } else {
                //The ball hit the center of the racket, let's add a little bit of a tragic accident(random) of his movement
                _ball.body.velocity.x = 2 + Math.random() * 8;
            }
        }

        function update() {
            //control par le joueur

            //CONTROL GYROSCOPE



            //CONTROL CLASSIQUE

            /*
            playerBet.x = game.input.x;


            var playerBetHalfWidth = playerBet.width / 2;

            if (playerBet.x < playerBetHalfWidth) {
                playerBet.x = playerBetHalfWidth;
            } else if (playerBet.x > game.width - playerBetHalfWidth) {
                playerBet.x = game.width - playerBetHalfWidth;
            }
            */

            //control par IA
            if (computerBet.x - ball.x < -15) {
                computerBet.body.velocity.x = computerBetSpeed;
            } else if (computerBet.x - ball.x > 15) {
                computerBet.body.velocity.x = -computerBetSpeed;
            } else {
                computerBet.body.velocity.x = 0;
            }

            //check des collisions
            game.physics.arcade.collide(ball, playerBet, ballHitsBet, null, this);
            game.physics.arcade.collide(ball, computerBet, ballHitsBet, null, this);
            checkGoal();


        }
    };
</script>
</body>

</html>
